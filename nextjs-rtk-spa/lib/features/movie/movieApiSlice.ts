import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";
import {Movie} from "@/app/types/movies";
import {BASE_URL} from "@/lib/Config";
import {RootState} from "@/lib/store";
export const movieApiSlice = createApi({
    baseQuery: fetchBaseQuery({ baseUrl: BASE_URL+"/api" ,
        prepareHeaders: (headers, {getState}) => {
            // By default, if we have a token in the store, let's use that for authenticated requests
            const state = (getState() as RootState);
            //console.log('prepareHeaders State ', state);
            if(state.auth.token)
            {
                headers.set('Authorization', 'Bearer '+state.auth.token);
            }
            return headers;

        }
        }),

    reducerPath: "moviesApi",
    // Tag types are used for caching and invalidation.
    tagTypes: ["Movie"],
    //refetchOnFocus: true,
    endpoints: (build) => ({
        // Supply generics for the return type (in this case `QuotesApiResponse`)
        // and the expected query argument. If there is no argument, use `void`
        // for the argument type instead.
        getAllMovie: build.query<Movie[], undefined>({
            query: () => `movies`,
            // `providesTags` determines which 'tag' is attached to the
            // cached data returned by the query.
            //providesTags:['Movie']
        }),
        saveMovie:build.mutation<Movie,Movie>({
            query: (movie:Movie) => ({
                url: `movies`,
                method: 'POST',
                body: movie,
            }),
            //invalidatesTags:['Movie'],
            //transformResponse: (response: { data: Movie }, meta, arg) => response.data,
            //Pessimistic update
            async onQueryStarted(movie:Movie , { dispatch, queryFulfilled }) {
                console.log('movie ',movie);
                let patchResult ;
                try {
                    const {data:savedMovie} = await queryFulfilled;
                    patchResult = dispatch(
                        movieApiSlice.util.updateQueryData('getAllMovie', undefined, (draft) => {
                            draft.push(savedMovie);
                            console.log('Draft ',draft);
                            //return draft;
                        }),
                    );
                    console.log('Saved Movie ',savedMovie);
                } catch(err) {
                    console.log('Err ',err);
                }
            }
        }),
        deleteMovie:build.mutation<Movie,string>({
            query: (movieId:string) => ({
                url: `movies/${movieId}`,
                method: 'DELETE',
            }),
            //invalidatesTags:['Movie'],
            //transformResponse: (response: { data: Movie }, meta, arg) => response.data,
            //Optimistic update
            async onQueryStarted(movieId:string , { dispatch, queryFulfilled }) {
                console.log('Movie ',movieId);
                const patchResult = dispatch(
                    movieApiSlice.util.updateQueryData('getAllMovie', undefined, (draft) => {
                        //console.log('Draft ',draft);
                        draft = draft.filter(item=>item._id != movieId);
                        //console.log('Draft ',draft);
                        return draft;
                    }),
                );
                try {
                    const {data:deletedMovie} = await queryFulfilled
                    console.log('delete movie ',deletedMovie);
                } catch(err) {
                    patchResult.undo();
                }
            },
        }),
        updateMovie:build.mutation<Movie,Movie>({
            query: (movie:Movie) => ({
                url: `movies/${movie._id}`,
                method: 'PUT',
            }),
            //invalidatesTags:['Movie'],
            //transformResponse: (response: { data: Movie }, meta, arg) => response.data,
            //Optimistic update
            async onQueryStarted(movie:Movie , { dispatch, queryFulfilled }) {
                console.log('Movie ',movie);
                const patchResult = dispatch(
                    movieApiSlice.util.updateQueryData('getAllMovie', undefined, (draft) => {
                        //console.log('Draft ',draft);
                        draft = draft.map(item=>item._id == movie._id?movie:item);
                        //console.log('Draft ',draft);
                        return draft;
                    }),
                );
                try {
                    const {data:updatedMovie} = await queryFulfilled
                    console.log('updatedMovie movie ',updatedMovie);
                } catch(err) {
                    patchResult.undo();
                }
            },
        }),
    }),
});

// Hooks are auto-generated by RTK-Query
// Same as `quotesApiSlice.endpoints.getQuotes.useQuery`
export const { useGetAllMovieQuery,
                useSaveMovieMutation,
                useDeleteMovieMutation,
                useUpdateMovieMutation} = movieApiSlice;